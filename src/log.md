[<img width=900 src="https://raw.githubusercontent.com/txt/mase/master/img/banner1.png">](https://github.com/txt/mase/blob/master/README.md)   
[At a glance...](https://github.com/txt/mase/blob/master/OVERVIEW.md) |
[Syllabus](https://github.com/txt/mase/blob/master/SYLLABUS.md) |
[Models](https://github.com/txt/mase/blob/master/MODELS.md) |
[Code](https://github.com/txt/mase/tree/master/src) |
[Lecturer](http://menzies.us) 



Logs are places to store records of past events. There are two types of logs:

+ _Num_ : for numbers
+ _Sym_ : for everything else. 

Those logs can be queried to find e.g. the highest
and lowest value of the number seen so far. Alternatively,
they can be queried to return values at the same probability
as the current log contents.

### Max Log Size

To avoid logs consuming all memory, logs store at
most _The.cache.keep_ entries (e.g. 128):

+ If more
than that number of entries arrive, then some old
entry (selected at random) will be deleted.
+ The nature of this cache means that some rare
events might be missed. To check for that, running
the code multiple times and, each time, double the
cache size. Stop when doubling the cache size stops
changing the output.

Just as an example of that process, here we are logging 1,000,000 numbers in a log with a cache of size 16.
Note that the resulting cache is much smaller than 1,000,000 items. Also, the contents of the cache
come from the entire range one to one million (so our log is not biased to just the first few samples:

     % python -i log.py
     >>> The.cache.keep = 16
     >>> log = Num()  
     >>> for x in xrange(1000000): log += x 
     >>> sorted(log._cache)
     [77748, 114712, 122521, 224268, 
     289880, 313675, 502464, 625036, 
     661881, 663207, 680085, 684674, 
     867075, 875594, 922141, 945896]
     >>> 

### Caching Slow Reports

Some of the things we want to report from these logs take a little while to calculate (e.g. finding the median
requires a sort of a numeric cache):

+ Such reports should be run and cached so they can be accessed many time without the need
for tedious recalculation. 
+ These reports become outdated if new log information arrives so the following
code deletes these reports if ever new data arrives.
+ The protocol for access those reports is to call _log.has().x_ where "x" is a field
  generated by the report.  Log subclasses generate reports using the special _report()_ method
  (see examples, below).

Just as an example of reporting, after the above run (where we logged 1,000,000 numbers), the following reports are available:

     >>> log.has().lo
     0 
     >>> log.has().hi
     945896
     >>> print log.has().median # 50th percentile
     662544.0
     >>> print log.has().iqr # (75-25)th percentile
     205194

Note that our median is not as expected (it should be around half a million). Why? Well, clearly a cache of size 16 is
too small to track a million numbers. So how many numbers do we need? Well, that depends on the distribution being explored
but here's how the median is effected by cache size for uniform distributions:

    >>> for size in [16,32,64,128,256]:
    ...     The.cache.keep=size
    ...     log = Num()
    ...     for x in xrange(1000000): log += x
    ...     print size, ":" log.has().median
    ... 
     16 : 637374.5
     32 : 480145.5
     64 : 520585.5
    128 : 490742.0
    256 : 470870.5


Note that we get pretty close to half a million with cache sizes at 32 or above. And the lesson: sometimes, a limited
sample can offer a useful approximation to a seemingly complex process.

## Standard Header
````python
<font color=red>   1:</font> from __future__ import division
<font color=red>   2:</font> import sys, random, math, datetime, time,re
<font color=red>   3:</font> sys.dont_write_bytecode = True
<font color=red>   4:</font> from base  import *
<font color=red>   5:</font> from stats import *
<font color=red>   6:</font> from a12 import *
````
## Classes

### Base Class: "Log"

````python
<font color=red>   7:</font> class Log():
<font color=red>   8:</font>   "Keep a random sample of stuff seen so far."
<font color=red>   9:</font>   def __init__(i,inits=[],label=''):
<font color=red>  10:</font>     i.label = label
<font color=red>  11:</font>     i._cache,i.n,i._report = [],0,None
<font color=red>  12:</font>     i.setup()
<font color=red>  13:</font>     map(i.__iadd__,inits)
<font color=red>  14:</font>   def __iadd__(i,x): #  magic method for "+="
<font color=red>  15:</font>     if x == None: return x # skip nothing
<font color=red>  16:</font>     i.n += 1
<font color=red>  17:</font>     changed = False
<font color=red>  18:</font>     if len(i._cache) < The.cache.keep: # not full
<font color=red>  19:</font>       changed = True
<font color=red>  20:</font>       i._cache += [x]               # then add
<font color=red>  21:</font>     else: # otherwise, maybe replace an old item
<font color=red>  22:</font>       if rand() <= The.cache.keep/i.n:
<font color=red>  23:</font>         changed = True
<font color=red>  24:</font>         i._cache[int(rand()*The.cache.keep)] = x
<font color=red>  25:</font>     if changed:      
<font color=red>  26:</font>       i._report = None # wipe out 'what follows'
<font color=red>  27:</font>       i.change(x)
<font color=red>  28:</font>     return i
<font color=red>  29:</font>   def any(i):  
<font color=red>  30:</font>     return  any(i._cache)
<font color=red>  31:</font>   def has(i):
<font color=red>  32:</font>     if i._report == None: i._report =  i.report()
<font color=red>  33:</font>     return i._report
<font color=red>  34:</font>   def setup(i): pass
<font color=red>  35:</font>   def change(i,x): pass
````

### Num

A _Num_ is a _Log_ for numbers. 

+ Tracks _lo_ and _hi_ values. 
+ Reports median and the IQR the (75-25)th range.
+ Generates numbers from the log by a three-way interpolation (see _ish()_).


````python
<font color=red>  36:</font> class Num(Log):
<font color=red>  37:</font>   def setup(i):
<font color=red>  38:</font>     i.lo, i.hi = 10**32, -10**32
<font color=red>  39:</font>     i.lessp = True
<font color=red>  40:</font>   def change(i,x): # update lo,hi
<font color=red>  41:</font>     i.lo = min(i.lo, x)
<font color=red>  42:</font>     i.hi = max(i.hi, x)
<font color=red>  43:</font>   def norm(i,x): # turn "x" into 0..1
<font color=red>  44:</font>     return (x - i.lo)/(i.hi - i.lo + 0.000001)
<font color=red>  45:</font>   def ordered():
<font color=red>  46:</font>     i.has()
<font color=red>  47:</font>     return i._cache
<font color=red>  48:</font>   def report(i): 
<font color=red>  49:</font>     lst = i._cache = sorted(i._cache)
<font color=red>  50:</font>     n   = len(lst)     
<font color=red>  51:</font>     return o(
<font color=red>  52:</font>       median= i.median(),
<font color=red>  53:</font>       iqr   = lst[int(n*.75)] - lst[int(n*.5)],
<font color=red>  54:</font>       lo    = i.lo, 
<font color=red>  55:</font>       hi    = i.hi)
<font color=red>  56:</font>   def ish(i,f=0.1): # return a num from  logged dist 
<font color=red>  57:</font>     return i.any() + f*(i.any() - i.any())
<font color=red>  58:</font>   def better(new,old):
<font color=red>  59:</font>     "better if (1)less median or (2)same and less iqr"
<font color=red>  60:</font>     t = The.misc.a12
<font color=red>  61:</font>     betterIqr = new.has().iqr < old.has().iqr
<font color=red>  62:</font>     if new.lessp:
<font color=red>  63:</font>       betterMed = new.has().median >= old.has().median
<font color=red>  64:</font>       same      = a12(old._cache, new._cache)  <= t
<font color=red>  65:</font>     else:
<font color=red>  66:</font>       betterMed = new.has().median <= old.has().median 
<font color=red>  67:</font>       same      = a12(new._cache, old._cache) <= t
<font color=red>  68:</font>     return betterMed, same, betterIqr
<font color=red>  69:</font>   def median(i):
<font color=red>  70:</font>     n = len(i._cache)
<font color=red>  71:</font>     p = n // 2
<font color=red>  72:</font>     if (n % 2):  return i._cache[p]
<font color=red>  73:</font>     q = p + 1
<font color=red>  74:</font>     q = max(0,(min(q,n)))
<font color=red>  75:</font>     return (i._cache[p] + i._cache[q])/2
<font color=red>  76:</font> 
<font color=red>  77:</font> def _num():
<font color=red>  78:</font>   i = Num([rand()      for _ in xrange(1000)])
<font color=red>  79:</font>   j = Num([rand()*1.25 for _ in xrange(1000)])
<font color=red>  80:</font>   print j.same(i)
<font color=red>  81:</font> 
````

WARNING: the call to _sorted_ in _report()_ makes this code
a candidate for a massive CPU suck (it is always sorting newly arrived data).
So distinguish between _adding_ things to a log in the _last_ era and 
using that information in the _next_ era (so the log from the last era
is staple in the current).

### Sym

A _Sym_ is a _Log_ for non-numerics.

+ Tracks frequency counts for symbols, and the most common symbol (the _mode_);
+ Reports the entropy of the space (a measure of diversity: lower values mean fewer rarer symbols);
+ Generated symbols from the log by returning symbols at the same probability of the frequency counts (see _ish()_).

````python
<font color=red>  82:</font> class Sym(Log):
<font color=red>  83:</font>   def setup(i):
<font color=red>  84:</font>     i.counts,i.mode,i.most={},None,0
<font color=red>  85:</font>   def report(i):
<font color=red>  86:</font>     for x in i._cache:
<font color=red>  87:</font>       c = i.counts[x] = i.counts.get(x,0) + 1
<font color=red>  88:</font>       if c > i.most:
<font color=red>  89:</font>         i.mode,i.most = x,c
<font color=red>  90:</font>     return o(dist= i.dist(), 
<font color=red>  91:</font>               ent = i.entropy(),
<font color=red>  92:</font>               mode= i.mode)
<font color=red>  93:</font>   def dist(i):
<font color=red>  94:</font>     d = i.counts
<font color=red>  95:</font>     n = sum(d.values())
<font color=red>  96:</font>     return sorted([(d[k]/n, k) for k in d.keys()], 
<font color=red>  97:</font>                   reverse=True)
<font color=red>  98:</font>   def ish(i):
<font color=red>  99:</font>     r,tmp = rand(),0
<font color=red> 100:</font>     for w,x in i.has().dist:
<font color=red> 101:</font>       tmp  += w
<font color=red> 102:</font>       if tmp >= r: 
<font color=red> 103:</font>         return x
<font color=red> 104:</font>     return x
<font color=red> 105:</font>   def entropy(i,e=0):
<font color=red> 106:</font>     for k in i.counts:
<font color=red> 107:</font>       p = i.counts[k]/len(i._cache)
<font color=red> 108:</font>       e -= p*log2(p) if p else 0
<font color=red> 109:</font>     return e    
````

#### Sym, Example

As an example of generating numbers from a distribution, consider the following code.
The logged population has plus, grapes and pears in the ration 2:1:1.
From that population, we can generate another distribution that is nearly the same:

    >>> symDemo()
    (0.5, 'plums'), (0.265625, 'grapes'), (0.234375, 'pears')]
    {'plums': 64, 'grapes': 34, 'pears': 30}

````python
<font color=red> 110:</font> def symDemo(n1=10,n2=1000):
<font color=red> 111:</font>   rseed()
<font color=red> 112:</font>   log= Sym((['plums']*(n1*2)) + ['grapes']*n1 + ['pears']*n1)
<font color=red> 113:</font>   found= Sym([log.ish() for _ in xrange(n2)])
<font color=red> 114:</font>   print found.has().dist
<font color=red> 115:</font>   print found.counts
<font color=red> 116:</font>   print sum(found.counts.values())
<font color=red> 117:</font> 
<font color=red> 118:</font> if __name__ == "__main__": eval(cmd()) 
<font color=red> 119:</font> 
<font color=red> 120:</font> 
````


_________

<img align=right src="https://raw.githubusercontent.com/txt/mase/master/img/pd-icon.png">Copyright Â© 2015 [Tim Menzies](http://menzies.us).
This is free and unencumbered software released into the public domain.   
For more details, see the [license](https://github.com/txt/mase/blob/master/LICENSE.md).

